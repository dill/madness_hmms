---
title: "HMM Madness: R, ARMA, and TMB"
author: "Richard Glennie"
date: "21/09/2017"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = TRUE)
```

Code to fit Poisson Hidden Markov Model (see REF) in R, RcppAramdillo and
Template Model Builder. Coding of the algorithm is strikingly similar between
the three programming approaches. Speed comparisons showed TMB to be faster in
all cases, particularly faster when sample size or the number of hidden states 
was high. Motivation for this comparison was to consider best approach for 
obtaining non-parametric bootstrap estimates of variance, requiring the HMM
to be fit many times. 

A basic knowledge of C++ makes coding the HMM algorithm in RcppArmadillo just as
easy as coding in R. Implementing Template Model Builder required more knowledge
of C++ and was less easy to use (see some notes on TMB below).

### File descriptions

* <code>poisson_hmm.R</code>: R functions to simulate Poisson HMM data,
  transform between natural and working parameters, and functions to fit HMM
  using R, RcppArmadillo, or Template Model Builder. 
* <code>hmm_arma.cpp</code>: C++ code to compute HMM likelihood using Armadillo
  and Rcpp. 
* <code>hmm_tmb.cpp</code>: C++ code to compute HMM likelihood using Template
  Model Builder.
* <code>simulation.R</code>: R function for performing simulation study on
  Poisson HMM using three programming approaches.
* <code>run.R</code>: R code to run a simulation study and output the average
  time taken to fit 999 data sets with R, ARMA and TMB under a few different
	sample sizes and hidden state dimensions.

### Speed Comparison  

```{r speed_comparison, echo = FALSE, results = "asis"} 
res <- read.csv("results.csv")[,-1]
kable(res, digits = 2, caption = "Average time (in secs) taken to maximise Poisson HMM likelihood, with different numbers of states (NStates), for 99 data sets, each with sample size n, using R, RcppArmadillo (ARMA) and Template Model Builder (TMB) (NA means > 5 minutes)", 
      col.names = c("n", "NStates", "R", "ARMA", "TMB"))
```


### Notes on Using TMB 

* A familiarity with C++ templates isn't essential, but is useful for 
debugging. The automatic differentation relies on the correct variables being
declared as <code>\<Type\></code>.
* The TMB library is not as robust as Eigen; sometimes operations that work in
Eigen do not work with TMB <code>matrix</code> and <code>vector</code> objects,
despite being based on Eigen. In most cases, this is because no polymorphic
alternative has been written to handle CppAD types. For example, <code>(v % w) *
A</code> where <code>v</code>,<code>w</code> are row vectors and <code>A</code> is a
matrix, fails because TMB does not have the required support for operation
chains. 
* The dynamic library produced when compiling TMB objects has to be loaded into
R. On some platforms (including mine), if you re-compile the object and re-load
the dynamic library, R either returns an error (because conflicting libraries
are loaded) or simply ignores the re-load and retains the old version of the
dynamic library. This is particularly frustrating when you are developing code:
edit TMB function, re-compile, re-load, does not re-load, cannot run editted
function and debug. The only solution I found was to restart R every time I
wanted to re-load the dynamic library. 


